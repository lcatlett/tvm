#!/usr/bin/env bash
# Terminus Version Manager (shim + manager)
# - Keeps PHARs under ~/.terminus/phars
# - Intercepts "terminus use/install/update/updates/list/versions/current/which/path/import"
# - Otherwise runs the currently selected PHAR transparently.
set -euo pipefail

# Config (overridable via env)
DIR="${TERMINUS_VM_DIR:-$HOME/.terminus/phars}"
CURRENT_FILE="$DIR/current"
PHP_BIN="${TERMINUS_PHP:-php}"
REPO_OWNER="pantheon-systems"
REPO_NAME="terminus"

# Utilities
msg() { printf "%s\n" "$*" >&2; }
die() { msg "Error: $*"; exit 1; }
tvm_mkdir() { [ -d "$DIR" ] || mkdir -p "$DIR"; }

gh_hdr() {
  if [ -n "${GITHUB_TOKEN:-}" ]; then
    printf "Authorization: Bearer %s" "$GITHUB_TOKEN"
  fi
}

tvm_list_tags() {
  # Returns tag names (up to 200) one per line
  local hdr; hdr="$(gh_hdr || true)"
  if [ -n "$hdr" ]; then
    curl -fsSL -H "$hdr" "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/tags?per_page=200"
  else
    curl -fsSL "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/tags?per_page=200"
  fi | grep -o "\"name\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | cut -d'"' -f4
}

tvm_latest_release_tag() {
  # Uses releases/latest to honor GitHub Release
  local hdr; hdr="$(gh_hdr || true)"
  if [ -n "$hdr" ]; then
    curl -fsSL -H "$hdr" "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/releases/latest"
  else
    curl -fsSL "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/releases/latest"
  fi | grep -o "\"tag_name\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | head -n1 | cut -d'"' -f4
}

tvm_sort_versions() {
  # Sort dot-separated numeric versions, portable on macOS/BSD
  # Input: lines of "X.Y.Z"
  awk -F. '{ printf "%010d.%010d.%010d %s\n", $1, ($2==""?0:$2), ($3==""?0:$3), $0 }' \
    | sort \
    | awk '{print $2}'
}

tvm_installed_versions() {
  ls -1 "$DIR"/terminus-*.phar 2>/dev/null \
    | sed -E 's#^.*/terminus-([0-9.]+)\.phar$#\1#' \
    | tvm_sort_versions
}

tvm_get_current_version() {
  [ -f "$CURRENT_FILE" ] && cat "$CURRENT_FILE" || true
}

tvm_set_current_version() {
  local ver="${1:?version required}"
  echo "$ver" > "$CURRENT_FILE"
}

tvm_resolve_version() {
  # Accepts:
  #   X.Y.Z -> exact
  #   X.Y   -> latest in X.Y.*
  #   X     -> latest in X.*
  #   latest -> latest GitHub release tag
  local want="${1:?version required}"
  case "$want" in
    latest) tvm_latest_release_tag; return ;;
  esac
  if printf "%s\n" "$want" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
    printf "%s" "$want"; return
  fi
  local tags; tags="$(tvm_list_tags)"
  if printf "%s\n" "$want" | grep -Eq '^[0-9]+$'; then
    printf "%s\n" "$tags" | grep -E "^${want}\." | tvm_sort_versions | tail -n1
    return
  fi
  if printf "%s\n" "$want" | grep -Eq '^[0-9]+\.[0-9]+$'; then
    printf "%s\n" "$tags" | grep -E "^${want}\." | tvm_sort_versions | tail -n1
    return
  fi
  # Fallback: assume full tag provided
  printf "%s" "$want"
}

tvm_download() {
  local ver="${1:?version required}"
  local dest="$DIR/terminus-$ver.phar"
  local tmp="$dest.part"
  local base="https://github.com/$REPO_OWNER/$REPO_NAME/releases/download/$ver"
  local url="$base/terminus.phar"
  if [ -f "$dest" ]; then
    msg "Terminus $ver already installed: $dest"
    return 0
  fi
  msg "Downloading Terminus $ver ..."
  if ! curl -fL "$url" -o "$tmp"; then
    rm -f "$tmp"
    die "Failed to download $url"
  fi
  chmod +x "$tmp"
  mv "$tmp" "$dest"
  # Optional SHA256 verification if available
  if curl -fsSL "$base/terminus.phar.sha256" -o "$dest.sha256" 2>/dev/null; then
    local expected actual
    expected="$(awk '{print $1}' "$dest.sha256" 2>/dev/null || true)"
    if command -v shasum >/dev/null 2>&1; then
      actual="$(shasum -a 256 "$dest" | awk '{print $1}')"
    elif command -v sha256sum >/dev/null 2>&1; then
      actual="$(sha256sum "$dest" | awk '{print $1}')"
    else
      actual=""
    fi
    if [ -n "$expected" ] && [ -n "$actual" ] && [ "$expected" != "$actual" ]; then
      rm -f "$dest" "$dest.sha256"
      die "SHA256 mismatch for Terminus $ver"
    fi
  fi
  msg "Installed Terminus $ver -> $dest"
}

tvm_use() {
  local want="${1:-}"
  [ -n "$want" ] || die "Usage: terminus use <version|major|major.minor|latest>"
  local ver; ver="$(tvm_resolve_version "$want")"
  [ -n "$ver" ] || die "Could not resolve version for '$want'"
  [ -f "$DIR/terminus-$ver.phar" ] || tvm_download "$ver"
  tvm_set_current_version "$ver"

  # Run plugin migration on first use
  migrate_existing_plugins

  # Set up plugin environment for the selected version
  setup_plugin_environment "$ver"

  printf "Now using Terminus %s\n" "$ver"

  # Show plugin environment info
  local major_version; major_version="$(echo "$ver" | cut -d. -f1)"
  printf "Plugin environment: ~/.terminus/plugins-%s.x\n" "$major_version"
}

tvm_update() {
  local mode="${1:-}"
  if [ "$mode" = "--all" ]; then
    msg "Fetching all missing releases (first page of tags) ..."
    local t success=0 failed=0 skipped=0
    while IFS= read -r t; do
      [ -n "$t" ] || continue
      # Skip pre-release versions and non-standard tags
      # Only process versions >= 1.0.0 as older versions likely don't have PHARs
      if printf "%s\n" "$t" | grep -Eq '^v?[1-9][0-9]*\.[0-9]+\.[0-9]+$'; then
        if tvm_download "$t"; then
          success=$((success + 1))
        else
          failed=$((failed + 1))
        fi
      else
        skipped=$((skipped + 1))
      fi
    done < <(tvm_list_tags)
    msg "Downloaded $success versions, $failed failed, $skipped skipped (pre-1.0 or invalid format)"
    return 0
  fi
  local latest; latest="$(tvm_latest_release_tag)"
  [ -n "$latest" ] || die "Could not determine latest release (rate-limited?). Set GITHUB_TOKEN."
  tvm_download "$latest"
  tvm_set_current_version "$latest"
  printf "Now using Terminus %s\n" "$latest"
}

tvm_list() {
  local curr; curr="$(tvm_get_current_version || true)"
  local any=0
  while IFS= read -r v; do
    any=1
    if [ -n "$curr" ] && [ "$v" = "$curr" ]; then
      printf "* %s (current)\n" "$v"
    else
      printf "  %s\n" "$v"
    fi
  done < <(tvm_installed_versions)
  [ "$any" = 1 ] || printf "(no versions installed yet)\n"
}

tvm_import() {
  local src="${1:-}"
  local ver="${2:-}"
  [ -n "$src" ] || die "Usage: terminus import <path-to-phar> [version]"
  [ -f "$src" ] || die "No such file: $src"
  if [ -z "$ver" ]; then
    # Try to detect version
    ver="$("$src" --version 2>/dev/null | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)"
    [ -n "$ver" ] || die "Could not auto-detect version; provide it explicitly."
  fi
  local dest="$DIR/terminus-$ver.phar"
  cp "$src" "$dest"
  chmod +x "$dest"
  printf "Imported Terminus %s -> %s\n" "$ver" "$dest"
}

setup_plugin_environment() {
  local version="${1:?version required}"
  local major_version; major_version="$(echo "$version" | cut -d. -f1)"
  local terminus_home="$HOME/.terminus"

  # Create version-specific directories if they don't exist
  local plugins_dir="$terminus_home/plugins-${major_version}.x"
  local deps_dir="$terminus_home/dependencies-${major_version}.x"

  mkdir -p "$plugins_dir" "$deps_dir"

  # Create or update symlinks to point to version-specific directories
  # Remove existing symlinks/directories first to avoid conflicts
  [ -L "$terminus_home/plugins" ] && rm "$terminus_home/plugins"
  [ -L "$terminus_home/dependencies" ] && rm "$terminus_home/dependencies"

  # Create symlinks to version-specific directories
  ln -sf "$plugins_dir" "$terminus_home/plugins"
  ln -sf "$deps_dir" "$terminus_home/dependencies"

  # Initialize dependencies directory with proper composer.json if it doesn't exist
  initialize_dependencies_directory "$deps_dir" "$major_version"

  # Clean up any stale composer lock files that might cause conflicts
  clean_dependencies_cache "$deps_dir"

  # Set environment variables for Terminus plugin discovery
  export TERMINUS_PLUGINS_DIR="$plugins_dir"
  export TERMINUS_DEPENDENCIES_DIR="$deps_dir"
  export TERMINUS_HOME="$terminus_home"

  # For Terminus 4.x compatibility, also set the terminus-dependencies directory
  # This is used by the plugin:refresh command
  export TERMINUS_TERMINUS_DEPENDENCIES_DIR="$deps_dir"
  export TERMINUS_DEPENDENCIES_BASE_DIR="$terminus_home/terminus-dependencies"

  # Create a symlink from terminus-dependencies to our version-specific directory
  local terminus_deps_link="$terminus_home/terminus-dependencies"
  if [ -L "$terminus_deps_link" ]; then
    rm "$terminus_deps_link"
  elif [ -d "$terminus_deps_link" ]; then
    # If it's a directory, back it up and replace with symlink
    mv "$terminus_deps_link" "$terminus_deps_link.backup.$(date +%s)" 2>/dev/null || true
  fi
  ln -sf "$deps_dir" "$terminus_deps_link"

  # Also ensure the symlinked dependencies directory is clean
  # This is important because Terminus uses ~/.terminus/dependencies directly
  if [ -L "$terminus_home/dependencies" ]; then
    clean_dependencies_cache "$terminus_home/dependencies"
  fi
}

initialize_dependencies_directory() {
  local deps_dir="${1:?dependencies directory required}"
  local major_version="${2:?major version required}"
  local composer_json="$deps_dir/composer.json"

  # If composer.json doesn't exist, create a clean one
  if [ ! -f "$composer_json" ]; then
    cat > "$composer_json" <<EOF
{
    "name": "pantheon-systems/terminus-dependencies",
    "require": {},
    "minimum-stability": "dev",
    "prefer-stable": true,
    "repositories": {
        "pantheon-systems/terminus-plugins": {
            "type": "path",
            "url": "../plugins-${major_version}.x",
            "options": {
                "symlink": true
            }
        }
    }
}
EOF
    msg "Initialized clean composer.json for Terminus ${major_version}.x dependencies"
  else
    # Check if the existing composer.json has the correct plugins path
    local expected_path="../plugins-${major_version}.x"
    if ! grep -q "\"url\": \"$expected_path\"" "$composer_json" 2>/dev/null; then
      # Update the plugins path in the existing composer.json
      if command -v sed >/dev/null 2>&1; then
        # Create a backup
        cp "$composer_json" "$composer_json.backup"

        # Update the plugins path using sed
        sed -i.tmp "s|\"url\": \"../plugins-[0-9]\\+\\.x\"|\"url\": \"$expected_path\"|g" "$composer_json" 2>/dev/null || {
          # If sed fails, restore backup and create new file
          mv "$composer_json.backup" "$composer_json"
          cat > "$composer_json" <<EOF
{
    "name": "pantheon-systems/terminus-dependencies",
    "require": {},
    "minimum-stability": "dev",
    "prefer-stable": true,
    "repositories": {
        "pantheon-systems/terminus-plugins": {
            "type": "path",
            "url": "../plugins-${major_version}.x",
            "options": {
                "symlink": true
            }
        }
    }
}
EOF
          msg "Reset composer.json for Terminus ${major_version}.x dependencies"
        }
        # Clean up temporary files
        rm -f "$composer_json.tmp" "$composer_json.backup" 2>/dev/null || true
      fi
    fi
  fi
}

clean_dependencies_cache() {
  local deps_dir="${1:?dependencies directory required}"

  # Remove composer.lock to prevent version conflicts
  if [ -f "$deps_dir/composer.lock" ]; then
    rm -f "$deps_dir/composer.lock"
    msg "Cleared composer.lock to prevent dependency conflicts"
  fi

  # Remove vendor directory to force fresh install
  if [ -d "$deps_dir/vendor" ]; then
    rm -rf "$deps_dir/vendor"
    msg "Cleared vendor directory to prevent dependency conflicts"
  fi

  # Remove any existing composer.json that might have conflicting dependencies
  # We'll recreate it with a clean state
  if [ -f "$deps_dir/composer.json" ]; then
    local has_custom_repos=0
    # Check if there are custom repositories we should preserve
    if grep -q '"repositories"' "$deps_dir/composer.json" 2>/dev/null; then
      if grep -q '"type": "path"' "$deps_dir/composer.json" 2>/dev/null; then
        has_custom_repos=1
      fi
    fi

    # If there are no custom repositories, or if there are conflicts, reset the file
    if [ "$has_custom_repos" -eq 0 ] || grep -q '"require".*{.*[^{}]*}' "$deps_dir/composer.json" 2>/dev/null; then
      rm -f "$deps_dir/composer.json"
      msg "Cleared composer.json to prevent dependency conflicts"
    fi
  fi
}

migrate_existing_plugins() {
  local terminus_home="$HOME/.terminus"
  local migrated_file="$terminus_home/.tvm_plugins_migrated"

  # Ensure terminus home directory exists
  mkdir -p "$terminus_home"

  # Only run migration once
  [ -f "$migrated_file" ] && return 0

  msg "Migrating existing plugins to version-specific directories..."

  # Migrate existing plugin directories to version-specific ones
  if [ -d "$terminus_home/plugins-3.x" ] && [ ! -L "$terminus_home/plugins-3.x" ]; then
    if [ ! -d "$terminus_home/plugins-3.x-original" ]; then
      mv "$terminus_home/plugins-3.x" "$terminus_home/plugins-3.x-original"
      mkdir -p "$terminus_home/plugins-3.x"
      # Copy contents back
      if [ -d "$terminus_home/plugins-3.x-original" ]; then
        cp -r "$terminus_home/plugins-3.x-original"/* "$terminus_home/plugins-3.x/" 2>/dev/null || true
      fi
    fi
  fi

  # Migrate terminus-dependencies directories
  for deps_dir in "$terminus_home"/terminus-dependencies-*; do
    if [ -d "$deps_dir" ] && [ ! -L "$deps_dir" ]; then
      local basename; basename="$(basename "$deps_dir")"
      # Try to determine version from directory name or contents
      local target_version="3"  # Default to 3.x for existing dependencies

      # Check if this looks like a 4.x dependencies directory
      if [ -f "$deps_dir/composer.json" ]; then
        if grep -q '"pantheon-systems/terminus": "^4"' "$deps_dir/composer.json" 2>/dev/null; then
          target_version="4"
        fi
      fi

      local target_dir="$terminus_home/dependencies-${target_version}.x"
      mkdir -p "$target_dir"

      # Copy contents to version-specific directory
      if [ -d "$deps_dir" ]; then
        cp -r "$deps_dir"/* "$target_dir/" 2>/dev/null || true
        msg "Migrated $basename to dependencies-${target_version}.x"
      fi
    fi
  done

  # Mark migration as complete
  touch "$migrated_file"
  msg "Plugin migration completed"
}

tvm_help() {
  cat <<HLP
TVM - Terminus Version Manager

Usage:
  tvm use <version|major|major.minor|latest>
  tvm install <version|major|major.minor|latest>
  tvm update|updates [--all]
  tvm list|versions
  tvm current|which
  tvm path
  tvm import <path-to-phar> [version]
  tvm plugins:migrate    - Migrate existing plugins to version-specific directories
  tvm plugins:status     - Show current plugin environment status
  tvm plugins:clean      - Clean dependencies cache to resolve conflicts

Aliases:
  tvm <command>         - Primary command (recommended)
  terminus <command>    - Smart routing (version management or Terminus execution)
  terminus-vm <command> - Direct manager access

Notes:
  - Manager subcommands can also be prefixed: terminus @vm <cmd> ...
  - For normal Terminus usage, run: terminus <args>
  - Plugin directories are now managed per major version (e.g., plugins-3.x, plugins-4.x)
  - Env vars:
      TERMINUS_VM_DIR (default: ~/.terminus/phars)
      TERMINUS_PHP    (default: php)
      GITHUB_TOKEN    (optional, to avoid API rate limits)
HLP
}

is_manager_cmd() {
  case "${1:-}" in
    @vm|use|install|update|updates|list|versions|current|which|path|import|plugins:migrate|plugins:status|plugins:clean|help|-h|--help) return 0 ;;
    *) return 1 ;;
  esac
}

tvm_plugins_status() {
  local curr; curr="$(tvm_get_current_version || true)"
  local terminus_home="$HOME/.terminus"

  if [ -z "$curr" ]; then
    printf "No Terminus version currently selected\n"
    return 1
  fi

  local major_version; major_version="$(echo "$curr" | cut -d. -f1)"
  local plugins_dir="$terminus_home/plugins-${major_version}.x"
  local deps_dir="$terminus_home/dependencies-${major_version}.x"

  printf "Current Terminus version: %s\n" "$curr"
  printf "Major version: %s.x\n" "$major_version"
  printf "Plugin directory: %s\n" "$plugins_dir"
  printf "Dependencies directory: %s\n" "$deps_dir"

  # Check if directories exist and show their status
  if [ -d "$plugins_dir" ]; then
    local plugin_count; plugin_count="$(find "$plugins_dir" -maxdepth 1 -type d | wc -l)"
    plugin_count=$((plugin_count - 1))  # Subtract 1 for the directory itself
    printf "Plugins directory exists with %d subdirectories\n" "$plugin_count"
  else
    printf "Plugins directory does not exist\n"
  fi

  if [ -d "$deps_dir" ]; then
    printf "Dependencies directory exists\n"
    if [ -f "$deps_dir/composer.json" ]; then
      printf "Dependencies have composer.json\n"
    fi
  else
    printf "Dependencies directory does not exist\n"
  fi

  # Check symlink status
  if [ -L "$terminus_home/plugins" ]; then
    local link_target; link_target="$(readlink "$terminus_home/plugins")"
    printf "Plugin symlink points to: %s\n" "$link_target"
  else
    printf "No plugin symlink found\n"
  fi

  if [ -L "$terminus_home/dependencies" ]; then
    local link_target; link_target="$(readlink "$terminus_home/dependencies")"
    printf "Dependencies symlink points to: %s\n" "$link_target"
  else
    printf "No dependencies symlink found\n"
  fi
}

tvm_plugins_clean() {
  local curr; curr="$(tvm_get_current_version || true)"
  local terminus_home="$HOME/.terminus"

  if [ -z "$curr" ]; then
    printf "No Terminus version currently selected\n"
    return 1
  fi

  local major_version; major_version="$(echo "$curr" | cut -d. -f1)"
  local deps_dir="$terminus_home/dependencies-${major_version}.x"

  printf "Cleaning dependencies cache for Terminus %s.x...\n" "$major_version"

  if [ -d "$deps_dir" ]; then
    clean_dependencies_cache "$deps_dir"
    initialize_dependencies_directory "$deps_dir" "$major_version"
    printf "✅ Dependencies cache cleaned successfully\n"
    printf "You can now run 'terminus plugin:refresh' to reinstall dependencies\n"
  else
    printf "Dependencies directory does not exist: %s\n" "$deps_dir"
    return 1
  fi
}

run_manager() {
  local sub="${1:-}"
  shift || true
  case "$sub" in
    @vm) sub="${1:-}"; shift || true ;;
  esac
  case "$sub" in
    use) tvm_mkdir; tvm_use "${1:-}";;
    install)
      tvm_mkdir
      local want="${1:-}"; [ -n "$want" ] || die "Usage: terminus install <version|major|major.minor|latest>"
      local ver; ver="$(tvm_resolve_version "$want")"; [ -n "$ver" ] || die "Could not resolve version."
      tvm_download "$ver"; tvm_set_current_version "$ver"

      # Run plugin migration and setup environment
      migrate_existing_plugins
      setup_plugin_environment "$ver"

      printf "Now using Terminus %s\n" "$ver"
      local major_version; major_version="$(echo "$ver" | cut -d. -f1)"
      printf "Plugin environment: ~/.terminus/plugins-%s.x\n" "$major_version"
      ;;
    update|updates) tvm_mkdir; tvm_update "${1:-}";;
    list|versions) tvm_mkdir; tvm_list;;
    current|which)
      tvm_mkdir
      local v; v="$(tvm_get_current_version || true)"
      if [ -n "$v" ]; then
        printf "%s/terminus-%s.phar\n" "$DIR" "$v"
      else
        die "No Terminus version selected."
      fi
      ;;
    path) printf "%s\n" "$DIR";;
    import) tvm_mkdir; tvm_import "${1:-}" "${2:-}";;
    plugins:migrate) tvm_mkdir; migrate_existing_plugins;;
    plugins:status) tvm_mkdir; tvm_plugins_status;;
    plugins:clean) tvm_mkdir; tvm_plugins_clean;;
    help|-h|--help|"") tvm_help;;
    *) die "Unknown command: $sub";;
  esac
}

exec_current() {
  tvm_mkdir
  local curr; curr="$(tvm_get_current_version || true)"
  local phar=""
  if [ -n "$curr" ] && [ -f "$DIR/terminus-$curr.phar" ]; then
    phar="$DIR/terminus-$curr.phar"
  else
    # Auto-install latest on first run
    local latest; latest="$(tvm_latest_release_tag || true)"
    if [ -n "$latest" ]; then
      tvm_download "$latest"
      tvm_set_current_version "$latest"
      phar="$DIR/terminus-$latest.phar"
      curr="$latest"
      msg "Auto-selected Terminus $latest"
    fi
  fi
  [ -f "$phar" ] || die "No Terminus PHAR available. Try: terminus updates"

  # Set up version-specific plugin environment before executing Terminus
  if [ -n "$curr" ]; then
    # Run plugin migration on first execution
    migrate_existing_plugins

    # Set up plugin environment for the current version
    setup_plugin_environment "$curr"
  fi

  exec "$PHP_BIN" "$phar" "$@"
}

main() {
  local base; base="$(basename "$0")"
  if [ "$base" = "terminus-vm" ] || [ "$base" = "tvm" ] || [ "${TVM_CALLED_AS:-}" = "tvm" ]; then
    run_manager "${1:-}" "${@:2}"
    exit $?
  fi
  # If first arg is a manager command, handle it; else delegate to PHAR
  if is_manager_cmd "${1:-}"; then
    run_manager "$@"
  else
    exec_current "$@"
  fi
}

main "$@"
